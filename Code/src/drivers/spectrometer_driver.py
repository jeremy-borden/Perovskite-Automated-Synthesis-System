# -*- coding: utf-8 -*-
"""spectrometer-rasberrypi.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1yK9vuu3NmPzc_fxeyzYqFBAWe1YKVdny

# **Spectrometer Script for Raspberry Pi**
"""

import serial
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import logging
import time
from data_processor import plot_spectra, save_all_to_csv  


# debugging
logging.basicConfig(level=logging.INFO)

class Spectrometer:
    """Handles Ossila Spectrometer communication, data collection, and saving to CSV"""

    def __init__(self, integration_time=5000, accumulations=3, averages=2): #set integration time, accumulation, average
        self.logger = logging.getLogger("Main Logger")
        self.integration_time = integration_time
        self.accumulations = accumulations
        self.averages = averages
        self.serial = None
        self.wavelengths = []
        self.measurements = {}  # to store intensities for Background, Reference, and Sample

    def connect(self):
        """Establish connection to the spectrometer"""
        
        
        port = "/dev/spectrometer"
        try:
            self.serial = serial.Serial(port, baudrate=115200, timeout=5)  
            self.logger.info(f"Connected to spectrometer on {port}")
        except serial.SerialException as e:
            self.logger.error(f"Error connecting to spectrometer: {e}")

    def disconnect(self):
        """Close the serial connection"""
        if self.is_connected():
            self.serial.close()
            self.logger.info("Spectrometer Disconnected")

    def is_connected(self):
        """Check if the spectrometer is connected"""
        return self.serial is not None and self.serial.is_open

    def send_command(self, command):
        """Send a command to the spectrometer and return the response"""
        if self.is_connected():
            self.serial.write((command + "\n").encode())
            time.sleep(0.1)
            response = self.serial.readline().decode().strip()
            self.logger.info(f"Sent: {command}, Received: {response}")
            return response
        return None

    def read_wavelengths(self):
        """Retrieve wavelength data from the spectrometer"""
        response = self.send_command("<wavs?>")
        self.wavelengths = np.fromstring(response, sep=',')
        self.logger.info(f"Read {len(self.wavelengths)} wavelength values.")

        return self.wavelengths


    def read_spectrum(self, measurement_type):
        """Read spectral intensity for a given measurement type"""
        self.logger.info("Reading spectrum...")

        if not self.is_connected():
            self.logger.warning("Spectrometer not connected.")
            return np.array([])

        self.send_command("<preflush:2>")   # Default preflush behavior
        self.send_command(f"<itime:{self.integration_time}>")
        self.send_command(f"<accum:{self.accumulations}>")
        self.send_command(f"<average:{self.averages}>")


        
        self.serial.reset_input_buffer()
       
        self.serial.write(b"<read:1>")
        time.sleep(0.5)

        raw_data = self.serial.read(3204)
        
        print(f"[DEBUG] Raw data length: {len(raw_data)}")
        print(f"[DEBUG] Raw data preview: {raw_data[:16].hex()}")  

        if len(raw_data) != 3204:
            self.logger.warning("Incomplete spectrum data received.")
            return np.array([])
            

        try:
            intensities = np.frombuffer(raw_data[2:3202], dtype=np.uint16)
        except Exception as e:
            self.logger.error(f"Failed to parse intensity data: {e}")
            return np.array([])

        # Store the collected data
        self.measurements[measurement_type] = intensities
        self.logger.info(f"Read {len(intensities)} intensity values for {measurement_type}.")
        print(f"[DEBUG] Sample Intensities: {intensities[:10]} ...")  # Shows first 10 values
        return intensities


"""1. Connects to the spectrometer

2. Sets integration time

3. Reads wavelengths

4. Collects three spectra types

5. Saves all data to CSV

6. Plots the spectral data

7. Disconnects safely
"""
